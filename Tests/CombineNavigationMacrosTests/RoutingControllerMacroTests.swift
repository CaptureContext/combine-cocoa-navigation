import XCTest
import MacroTesting
import CombineNavigationMacros

final class RoutingControllerMacroTests: XCTestCase {
	override func invokeTest() {
		withMacroTesting(
			isRecording: false,
			macros: [
				"RoutingController": RoutingControllerMacro.self
			]
		) {
			super.invokeTest()
		}
	}

	func testAttachmentToStruct() {
		assertMacro {
			"""
			@RoutingController
			struct CustomController {}
			"""
		} diagnostics: {
			"""
			@RoutingController
			struct CustomController {}
			â•°â”€ ðŸ›‘ `@RoutingController` must be attached to a class declaration.
			"""
		}
	}

	func testAttachmentToEnum() {
		assertMacro {
			"""
			@RoutingController
			enum CustomController {}
			"""
		} diagnostics: {
			"""
			@RoutingController
			enum CustomController {}
			â•°â”€ ðŸ›‘ `@RoutingController` must be attached to a class declaration.
			"""
		}
	}

	func testAttachmentToActor() {
		assertMacro {
			"""
			@RoutingController
			actor CustomController {}
			"""
		} diagnostics: {
			"""
			@RoutingController
			actor CustomController {}
			â•°â”€ ðŸ›‘ `@RoutingController` must be attached to a class declaration.
			"""
		}
	}

	func testAttachmentToClass() {
		assertMacro {
			"""
			@RoutingController
			final class CustomController {}
			"""
		} expansion: {
			"""
			final class CustomController {}

			extension CustomController: CombineNavigation.RoutingController {
			    /// Container for captured destinations without referring to self
			    ///
			    /// > Generated by `CombineNavigationMacros.RoutingController` macro
			    ///
			    /// Use in `navigationDestination`/`navigationStack` methods to map
			    /// routes to specific destinations using `destinations` method
			    public struct Destinations {
			    	public subscript(_ id: some Hashable) -> UIViewController? {
			    		return nil
			    	}
			    }

			    public func _makeDestinations() -> Destinations {
			    	 return Destinations()
			    }
			}
			"""
		}
	}

	func testAttachmentToClass_TreeDestinations() {
		assertMacro {
			"""
			@RoutingController
			final class CustomController {
				@TreeDestination
				var firstDetailController: CocoaViewController?
				@TreeDestination
				var secondDetailController: CocoaViewController?
			}
			"""
		} expansion: {
			"""
			final class CustomController {
				@TreeDestination
				var firstDetailController: CocoaViewController?
				@TreeDestination
				var secondDetailController: CocoaViewController?
			}

			extension CustomController: CombineNavigation.RoutingController {
				/// Container for captured destinations without referring to self
				///
				/// > Generated by `CombineNavigationMacros.RoutingController` macro
				///
				/// Use in `navigationDestination`/`navigationStack` methods to map
				/// routes to specific destinations using `destinations` method
				public struct Destinations {
					@TreeDestination
					var firstDetailController: CocoaViewController?

					@TreeDestination
					var secondDetailController: CocoaViewController?

					public subscript(_ id: some Hashable) -> UIViewController? {
						return nil
					}
				}

				public func _makeDestinations() -> Destinations {
					return Destinations(
						firstDetailController: $firstDetailController,
						secondDetailController: $secondDetailController
					)
				}
			}
			"""
		}
	}

	func testAttachmentToClass_StackDestinations() {
		assertMacro {
			"""
			@RoutingController
			final class CustomController {
				@StackDestination<Int, CocoaViewController>
				var firstDetailController
				@StackDestination
				var secondDetailController: [Int: CocoaViewController]
			}
			"""
		} expansion: {
			"""
			final class CustomController {
				@StackDestination<Int, CocoaViewController>
				var firstDetailController
				@StackDestination
				var secondDetailController: [Int: CocoaViewController]
			}

			extension CustomController: CombineNavigation.RoutingController {
				/// Container for captured destinations without referring to self
				///
				/// > Generated by `CombineNavigationMacros.RoutingController` macro
				///
				/// Use in `navigationDestination`/`navigationStack` methods to map
				/// routes to specific destinations using `destinations` method
				public struct Destinations {
					@StackDestination<Int, CocoaViewController>
					var firstDetailController

					@StackDestination
					var secondDetailController: [Int: CocoaViewController]

					public subscript(_ id: some Hashable) -> UIViewController? {
						func controller<ID, Controller>(
							for s: StackDestination<ID, Controller>
						) -> UIViewController? {
							return (id as? ID).flatMap {
								s.wrappedValue[$0]
							}
						}

						return controller(for: _firstDetailController)
						?? controller(for: _secondDetailController)
					}
				}

				public func _makeDestinations() -> Destinations {
					return Destinations(
						firstDetailController: $firstDetailController,
						secondDetailController: $secondDetailController
					)
				}
			}
			"""
		}
	}

	// Specifying wrappedValue type expricitly is supported only
	// for DictionaryType literal
	func testAttachmentToClass_StackDestinations_DictionaryType() {
		assertMacro {
			"""
			@RoutingController
			final class CustomController {
				@StackDestination
				var firstDetailController: Dictionary<Int, CocoaViewController>
			}
			"""
		} expansion: {
			"""
			final class CustomController {
				@StackDestination
				var firstDetailController: Dictionary<Int, CocoaViewController>
			}

			extension CustomController: CombineNavigation.RoutingController {
				/// Container for captured destinations without referring to self
				///
				/// > Generated by `CombineNavigationMacros.RoutingController` macro
				///
				/// Use in `navigationDestination`/`navigationStack` methods to map
				/// routes to specific destinations using `destinations` method
				public struct Destinations {
					@StackDestination
					var firstDetailController: Dictionary<Int, CocoaViewController>

					public subscript(_ id: some Hashable) -> UIViewController? {
						func controller<ID, Controller>(
							for s: StackDestination<ID, Controller>
						) -> UIViewController? {
							return (id as? ID).flatMap {
								s.wrappedValue[$0]
							}
						}

						return controller(for: _firstDetailController)
					}
				}

				public func _makeDestinations() -> Destinations {
					return Destinations(
						firstDetailController: $firstDetailController
					)
				}
			}
			"""
		}
	}

	func testAttachmentToClass_CustomTreeDestinations() {
		assertMacro {
			"""
			@RoutingController
			final class CustomController {
				@CustomTreeDestination
				var firstDetailController: CocoaViewController?
				@CustomTreeDestination
				var secondDetailController: CocoaViewController?
			}
			"""
		} expansion: {
			"""
			final class CustomController {
				@CustomTreeDestination
				var firstDetailController: CocoaViewController?
				@CustomTreeDestination
				var secondDetailController: CocoaViewController?
			}

			extension CustomController: CombineNavigation.RoutingController {
				/// Container for captured destinations without referring to self
				///
				/// > Generated by `CombineNavigationMacros.RoutingController` macro
				///
				/// Use in `navigationDestination`/`navigationStack` methods to map
				/// routes to specific destinations using `destinations` method
				public struct Destinations {
					@CustomTreeDestination
					var firstDetailController: CocoaViewController?

					@CustomTreeDestination
					var secondDetailController: CocoaViewController?

					public subscript(_ id: some Hashable) -> UIViewController? {
						return nil
					}
				}

				public func _makeDestinations() -> Destinations {
					return Destinations(
						firstDetailController: $firstDetailController,
						secondDetailController: $secondDetailController
					)
				}
			}
			"""
		}
	}

	func testAttachmentToClass_CustomStackDestinations() {
		assertMacro {
			"""
			@RoutingController
			final class CustomController {
				@CustomStackDestination
				var firstDetailController: [Int: CocoaViewController]

				@CustomStackDestinationOf<MyCoolIdentifableVC>
				var secondDetailController
			}
			"""
		} expansion: {
			"""
			final class CustomController {
				@CustomStackDestination
				var firstDetailController: [Int: CocoaViewController]

				@CustomStackDestinationOf<MyCoolIdentifableVC>
				var secondDetailController
			}

			extension CustomController: CombineNavigation.RoutingController {
				/// Container for captured destinations without referring to self
				///
				/// > Generated by `CombineNavigationMacros.RoutingController` macro
				///
				/// Use in `navigationDestination`/`navigationStack` methods to map
				/// routes to specific destinations using `destinations` method
				public struct Destinations {
					@CustomStackDestination
					var firstDetailController: [Int: CocoaViewController]


					@CustomStackDestinationOf<MyCoolIdentifableVC>
					var secondDetailController

					public subscript(_ id: some Hashable) -> UIViewController? {
						func controller<ID, Controller>(
							for s: StackDestination<ID, Controller>
						) -> UIViewController? {
							return (id as? ID).flatMap {
								s.wrappedValue[$0]
							}
						}

						return controller(for: _firstDetailController)
						?? controller(for: _secondDetailController)
					}
				}

				public func _makeDestinations() -> Destinations {
					return Destinations(
						firstDetailController: $firstDetailController,
						secondDetailController: $secondDetailController
					)
				}
			}
			"""
		}
	}
}
