import MacroToolkit
import SwiftDiagnostics
import SwiftSyntax
import SwiftSyntaxMacros

public struct RoutingControllerMacro {
	static let moduleName = "CombineNavigation"
	static let conformanceName = "RoutingControllerProtocol"
	static var qualifiedConformanceName: String { "\(Self.moduleName).\(Self.conformanceName)" }
	static var conformanceNames: [String] { [Self.conformanceName, Self.qualifiedConformanceName] }
}

extension RoutingControllerMacro: ExtensionMacro {
	public static func expansion<
		Declaration: DeclGroupSyntax,
		Type: TypeSyntaxProtocol,
		Context: MacroExpansionContext
	>(
		of node: AttributeSyntax,
		attachedTo declaration: Declaration,
		providingExtensionsOf type: Type,
		conformingTo protocols: [TypeSyntax],
		in context: Context
	) throws -> [ExtensionDeclSyntax] {
		guard let decl = ClassDeclSyntax(declaration) else {
			return context.diagnose(.requiresClassDeclaration(declaration), return: [])
		}

		let alreadyConforms = decl.inheritanceClause?.inheritedTypes.contains(where: {
			Self.conformanceNames.contains($0.type.trimmedDescription)
		}) == true

		if alreadyConforms { return [] }

		var extensionDecl: ExtensionDeclSyntax = {
			let decl: DeclSyntax = """
			extension \(type.trimmed): \(raw: Self.qualifiedConformanceName) {}
			"""
			return decl.cast(ExtensionDeclSyntax.self)
		}()

		extensionDecl.memberBlock = MemberBlockSyntax(
			members: MemberBlockItemListSyntax(
				makeExtensionMembers(
					from: navigationChildren(for: decl)
				)
			)
		)

		return [extensionDecl]
	}

	static func navigationChildren(for declaration: ClassDeclSyntax) -> [MemberBlockItemSyntax] {
		declaration.memberBlock.members.compactMap { member in
			guard let variable = member.decl.as(VariableDeclSyntax.self)
			else { return nil }

			let isNavigationChild = variable.attributes.contains { attribute in
				guard let attribute = attribute.as(AttributeSyntax.self)
				else { return false }
				return attribute.attributeName.description.hasSuffix("Destination")
			}

			return isNavigationChild ? member : nil
		}
	}

	static func makeExtensionMembers(
		from navigationChildren: [MemberBlockItemSyntax]
	) -> [MemberBlockItemSyntax] {
		let destinationStructDocComment: String = """
		/// Container for captured destinations without referring to self
		///
		/// > Generated by `CombineNavigation.RoutingController` macro
		///
		/// Use in `navigationDestination`/`navigationStack` methods to map
		/// routes to specific destinations using `destinations` method
		"""

		let destinationsStructDecl = StructDeclSyntax(
			leadingTrivia: Trivia.init(
				pieces: destinationStructDocComment
					.components(separatedBy: .newlines)
					.flatMap { [.docLineComment($0), .newlines(1)] }
			),
			modifiers: DeclModifierListSyntax {
				DeclModifierSyntax(name: "public")
			},
			name: "Destinations",
			memberBlock: MemberBlockSyntax(members: MemberBlockItemListSyntax(navigationChildren)),
			trailingTrivia: .newlines(2)
		).as(DeclSyntax.self)

		let destinationsInitParams = navigationChildren.compactMap { member in
			Variable(member.decl)?.bindings.first?.identifier
		}.map { identifier in
			"\(identifier): $\(identifier)"
		}.joined(separator: ",\n")

		let makeDestinationsFuncDecl: DeclSyntax = """
		public func _makeDestinations() -> Destinations {
			Destinations(
				\(raw: destinationsInitParams)
			)
		}
		"""

		return [
			destinationsStructDecl,
			makeDestinationsFuncDecl
		]
			.compactMap { $0 }
			.map { MemberBlockItemSyntax(decl: $0) }
	}
}

fileprivate extension Diagnostic {
	static func requiresClassDeclaration(_ node: some DeclGroupSyntax) -> Self {
		func _requiresClassDeclaration(_ node: some SyntaxProtocol) -> Self {
			DiagnosticBuilder(for: node)
				.messageID(domain: "RoutingController", id: "requires_class_declaration")
				.message("`@RoutingController` must be attached to a class declaration.")
				.build()
		}

		return node.as(EnumDeclSyntax.self).map { decl in
			_requiresClassDeclaration(decl.enumKeyword)
		} ?? node.as(StructDeclSyntax.self).map { decl in
			_requiresClassDeclaration(decl.structKeyword)
		} ?? node.as(ActorDeclSyntax.self).map { decl in
			_requiresClassDeclaration(decl.actorKeyword)
		} ?? {
			_requiresClassDeclaration(node)
		}()
	}
}
