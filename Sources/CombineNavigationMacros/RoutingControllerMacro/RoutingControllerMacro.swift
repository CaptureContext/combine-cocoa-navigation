import MacroToolkit
import SwiftDiagnostics
import SwiftSyntax
import SwiftSyntaxMacros

public struct RoutingControllerMacro {
	static let moduleName = "CombineNavigation"
	static let conformanceName = "RoutingController"
	static var qualifiedConformanceName: String { "\(Self.moduleName).\(Self.conformanceName)" }
	static var conformanceNames: [String] { [Self.conformanceName, Self.qualifiedConformanceName] }
}

extension RoutingControllerMacro: ExtensionMacro {
	public static func expansion<
		Declaration: DeclGroupSyntax,
		Type: TypeSyntaxProtocol,
		Context: MacroExpansionContext
	>(
		of node: AttributeSyntax,
		attachedTo declaration: Declaration,
		providingExtensionsOf type: Type,
		conformingTo protocols: [TypeSyntax],
		in context: Context
	) throws -> [ExtensionDeclSyntax] {
		guard let decl = ClassDeclSyntax(declaration) else {
			return context.diagnose(.requiresClassDeclaration(declaration), return: [])
		}

		let alreadyConforms = decl.inheritanceClause?.inheritedTypes.contains(where: {
			Self.conformanceNames.contains($0.type.trimmedDescription)
		}) == true

		if alreadyConforms { return [] }

		var extensionDecl: ExtensionDeclSyntax = {
			let decl: DeclSyntax = """
			extension \(type.trimmed): \(raw: Self.qualifiedConformanceName) {}
			"""
			return decl.cast(ExtensionDeclSyntax.self)
		}()

		do {
			extensionDecl.memberBlock = MemberBlockSyntax(
				members: MemberBlockItemListSyntax(
					try makeDeclarationsExtensionMembers(for: decl)
				)
			)
		} catch {
			return (error as! DiagnosticsError).diagnostics.first.map { diagnostic in
				context.diagnose(diagnostic, return: [ExtensionDeclSyntax]())
			} ?? []
		}

		return [extensionDecl]
	}

	/// Creates an array of MemberBlockItemSyntax from
	static func makeDeclarationsExtensionMembers(
		for declaration: ClassDeclSyntax
	) throws -> [MemberBlockItemSyntax] {
		let navigationDestinations: [Variable] = declaration.memberBlock.members
			.compactMap { member in
				guard let variable = Variable(member.decl)
				else { return nil }

				let isNavigationChild = variable.attributes.contains { attribute in
					switch attribute {
					case let .attribute(attribute) where
						attribute.name.name.contains("TreeDestination") ||
						attribute.name.name.contains("StackDestination"):
						return true
					default:
						return false
					}
				}

				return isNavigationChild ? variable : nil
			}

		let destinationStructDocComment: String = """
		/// Container for captured destinations without referring to self
		///
		/// > Generated by `CombineNavigationMacros.RoutingController` macro
		///
		/// Use in `navigationDestination`/`navigationStack` methods to map
		/// routes to specific destinations using `destinations` method
		"""

		if navigationDestinations.isEmpty {
			var destinationsStructDecl: DeclSyntax = """
			\(raw: destinationStructDocComment)
			public struct Destinations {
				public subscript(_ id: some Hashable) -> UIViewController? {
					return nil
				}
			}
			"""

			destinationsStructDecl.trailingTrivia = .newlines(2)

			let makeDestinationsFuncDecl: DeclSyntax = """
			public func _makeDestinations() -> Destinations {
				 return Destinations()
			}
			"""

			return [
				MemberBlockItemSyntax(decl: destinationsStructDecl),
				MemberBlockItemSyntax(decl: makeDestinationsFuncDecl)
			]
		}

		var destinationsStructMembers = navigationDestinations
			.map(\._syntax)
			.map {
				var decl = MemberBlockItemSyntax(decl: $0)
				decl.trailingTrivia = .newlines(1)
				return decl
			}

		let stackDestinations: [String] = navigationDestinations.compactMap { decl in
			guard
				let attribute = decl.attributes.first?.attribute,
				attribute.name.name.contains("StackDestination"),
				let identifier = decl.bindings.first?.identifier
			else { return .none }

			return identifier
		}

		if !stackDestinations.isEmpty {
			let erasedIDType = "some Hashable"

			let castedIDDecl: DeclSyntax = """
			func controller<ID, Controller>(
				for s: StackDestination<ID, Controller>
			) -> UIViewController? {
				return (id as? ID).flatMap {
					s.wrappedValue[$0]
				}
			}
			"""

			var stackDestinationsCoalecing: String {
				return stackDestinations
					.map { "controller(for: _\($0))" }
					.joined(separator: "\n\t?? ")
			}

			let destinationsStructSubscriptDecl: DeclSyntax =
			"""
			\npublic subscript(_ id: \(raw: erasedIDType)) -> UIViewController? {
				\(castedIDDecl)

				return \(raw: stackDestinationsCoalecing)
			}
			"""

			destinationsStructMembers.append(MemberBlockItemSyntax(
				decl: destinationsStructSubscriptDecl
			))
		} else {
			let destinationsStructSubscriptDecl: DeclSyntax = """
			\npublic subscript(_ id: some Hashable) -> UIViewController? {
				return nil
			}
			"""

			destinationsStructMembers.append(MemberBlockItemSyntax(
				decl: destinationsStructSubscriptDecl
			))
		}

		let destinationsStructDecl = StructDeclSyntax(
			leadingTrivia: Trivia.init(
				pieces: destinationStructDocComment
					.components(separatedBy: .newlines)
					.flatMap { [.docLineComment($0), .newlines(1)] }
			),
			modifiers: DeclModifierListSyntax {
				DeclModifierSyntax(name: "public")
			},
			name: "Destinations",
			memberBlock: MemberBlockSyntax(
				members: MemberBlockItemListSyntax(
					destinationsStructMembers
				)
			),
			trailingTrivia: .newlines(2)
		).as(DeclSyntax.self)

		let destinationsInitParams = navigationDestinations.compactMap(
			\.bindings.first?.identifier
		).map { identifier in
			"\(identifier): $\(identifier)"
		}.joined(separator: ",\n")

		let makeDestinationsFuncDecl: DeclSyntax = """
		public func _makeDestinations() -> Destinations {
			return Destinations(
				\(raw: destinationsInitParams)
			)
		}
		"""

		return [
			destinationsStructDecl,
			makeDestinationsFuncDecl
		]
			.compactMap { $0 }
			.map { MemberBlockItemSyntax(decl: $0) }
	}
}

fileprivate extension Diagnostic {
	static func requiresClassDeclaration(_ node: some DeclGroupSyntax) -> Self {
		func _requiresClassDeclaration(_ node: some SyntaxProtocol) -> Self {
			DiagnosticBuilder(for: node)
				.messageID(domain: "RoutingController", id: "requires_class_declaration")
				.message("`@RoutingController` must be attached to a class declaration.")
				.build()
		}

		return node.as(EnumDeclSyntax.self).map { decl in
			_requiresClassDeclaration(decl.enumKeyword)
		} ?? node.as(StructDeclSyntax.self).map { decl in
			_requiresClassDeclaration(decl.structKeyword)
		} ?? node.as(ActorDeclSyntax.self).map { decl in
			_requiresClassDeclaration(decl.actorKeyword)
		} ?? {
			_requiresClassDeclaration(node)
		}()
	}

	static func requiresDictionaryLiteralForStackDestination(_ node: AttributeSyntax) -> Self {
		DiagnosticBuilder(for: node)
			.messageID(domain: "RoutingController", id: "requires_dictionary_literal_for_stack_destination")
			.message("""
			`@StackDestination` requires explicit wrapper type \
			or dictionary type literal declaration for value.
			""")
			.build()
	}
}
